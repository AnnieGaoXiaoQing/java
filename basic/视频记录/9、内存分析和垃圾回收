1、虚拟机：栈、堆、方法区（事实：方法区也在堆里）
  栈：
     a、栈描述的是方法执行的内存模型，每个方法调用都会创建一个栈帧（存储局部变量、操作数、方法出口）
     b、JVM为每个线程创建一个栈，用于存放该线程执行的方法信息（实际参数、局部变量等）
     c、栈属于线程私有，不能线程间共享
     d、“先进后出，后进先出”
     e、栈由系统自动分配，是一个连续的内存空间
  堆：
     a、存放创建好的对象和数组
     b、JVM只有一个堆，被所有线程共享
     c、堆是一个不连续的内存空间，分配灵活，速度慢！
  方法区：也叫静态区
     a、JVM只有一个方法区，被所有线程共享
     b、方法区实际上也是堆，只是用于存储类、常量的信息
     c、用来存储程序中永远不变的内容（类信息、静态变量、字符串常量等）

2、垃圾回收算法
   引用计数法：对象引用次数（缺点：循环引用则无法识别）
   引用可达法：根据搜索法，
3、分代垃圾回收
    三种状态：年轻代、年老代、持久代（不需要考虑回收持久代）
    存储地方：
        年轻代：Eden、Survivor
        持久代：Tenured/Old
        持久代：方法区
4、垃圾回收种类
    Minor GC：用于清理年轻代区域，Eden区域满了则触发一次MinorGC，清理无用对象，将有用对象复制到
"Survior1"、"Survior2",(这两个区，大小相同，同一时刻只有一个在用，一个为空)
    Major GC：清理老年代
    FULL GC：用于清理年轻代、老年代区域，成本较高，会对系统性能产生影响。（JVM主要优化对象）

5、垃圾回收过程
   a、新创建的对象，大多数都在Eden区域
   b、当Eden满了（达到一定比例）不能创建新对象，则触发垃圾回收（GC）,将无用对象清理掉，然后将剩余对象复制到Survior，如S1，同时
      清空Eden区
   c、当Eden区再次满了，会将S1中不能被清空的对象存到另外一个Survior中，如S2，同时将Eden区中不能被清空的对象，也复制到S1中，保证Eden
      和S1，均被清空
   d、重复多次（默认15次）Suvior中没有被清空的对象，则会复制到老年代Old（Tenured）区
   e、当Old区满了，则会触发一个一次完整的垃圾回收（FullGC）,新生代的垃圾回收称为（minorGC）
6、
